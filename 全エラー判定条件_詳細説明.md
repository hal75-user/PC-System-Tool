# 全エラー判定条件 - 詳細説明

## 概要

このドキュメントは、PC System Tool で実装されているすべてのエラー検出ロジックと判定条件を詳細に説明します。
**注意: このドキュメントは現在のコードを変更せずに、既存の判定ロジックを整理したものです。**

---

## 目次

1. [CSVファイル名重複エラー](#1-csvファイル名重複エラー)
2. [ゼッケン重複エラー](#2-ゼッケン重複エラー)
3. [区間通過順エラー](#3-区間通過順エラー)
4. [ゼッケン通過順エラー](#4-ゼッケン通過順エラー)
5. [ステータス不正エラー](#5-ステータス不正エラー)
6. [計測タイプ確認エラー](#6-計測タイプ確認エラー)
7. [計測データ不備エラー](#7-計測データ不備エラー)
8. [エラー確認可否について](#8-エラー確認可否について)
9. [同一エラー判定ロジック](#9-同一エラー判定ロジック)

---

## 1. CSVファイル名重複エラー

### エラータイプ
`csv_duplicate`

### 判定条件

#### 検出タイミング
Race読み込み時（validate_all関数）

#### 検出ロジック
1. レースフォルダ内のすべてのCSVファイルを取得
2. 各ファイル名から拡張子（.csv）を除去
3. ファイル名をアンダースコア（_）で分割して区間名を抽出
   - 例: `PC3GOAL.csv` → `PC3GOAL`
   - 例: `PC3GOAL_PC4START.csv` → `PC3GOAL`, `PC4START`
4. 区間名をキーに、ファイル名のリストを作成
5. **同じ区間名が2つ以上のファイルに存在する場合にエラー**

#### エラーメッセージ例
```
⚠️ CSVファイル名重複エラー
区間 'PC3GOAL' が複数のファイルに存在します:
  - PC3GOAL.csv
  - PC3GOAL_PC4START.csv
ファイル名を修正してください。
```

#### 確認可否
**不可（allow_confirmation=False）**

このエラーは重大な問題のため、必ず修正する必要があります。

#### 実装関数
`check_duplicate_filenames(race_folder)`

---

## 2. ゼッケン重複エラー

### エラータイプ
`zekken_duplicate`

### 判定条件

#### 検出タイミング
Race読み込み時（validate_all関数）

#### 検出ロジック
1. すべてのレース結果を区間ごとにグループ化
2. 各区間内でゼッケン番号の出現回数をカウント
3. **同じ区間で同じゼッケンが2回以上出現する場合にエラー**

#### エラーメッセージ例
```
⚠️ ゼッケン重複エラー
区間 'PC1' でゼッケン 5 が2回出現しています。
CSVファイルを確認してください。
```

#### 確認可否
**不可（allow_confirmation=False）**

このエラーは重大な問題のため、必ず修正する必要があります。

#### 実装関数
`check_duplicate_zekken_in_section(results)`

---

## 3. 区間通過順エラー

### エラータイプ
`section_order`

### 判定条件

#### 検出タイミング
Race読み込み時（validate_all関数）

#### 検出ロジック
1. グループごとに区間をグループ化
2. グループに2つ以上の区間がない場合はスキップ
3. 各区間のゼッケン通過順序を取得（ステータスがない結果のみ）
4. **基準区間（グループの最初の区間）の通過順序と他の区間を比較**
5. 以下のいずれかに該当する場合にエラー:
   - **順序不一致**: 共通ゼッケンの通過順序が基準区間と異なる
   - **歯抜け**: 基準区間にあるゼッケンが他の区間に存在しない
   - **追加**: 基準区間にないゼッケンが他の区間に存在する

#### 詳細な判定基準

##### 順序不一致の判定
```python
# 共通するゼッケンが2つ以上必要
common_zekken = base_set & current_set
if len(common_zekken) < 2:
    continue  # スキップ

# 基準区間での順序
base_common_order = [z for z in base_order if z in common_zekken]
# 現在の区間での順序
current_common_order = [z for z in current_order if z in common_zekken]

# 順序が異なる場合にエラー
if base_common_order != current_common_order:
    # エラーを記録
```

##### 歯抜けの判定
```python
# 基準にあるが現在にない
missing = base_set - current_set
if missing:
    # エラーを記録
```

##### 追加の判定
```python
# 現在にあるが基準にない
extra = current_set - base_set
if extra:
    # エラーを記録
```

#### エラーメッセージ例
```
⚠️ 区間通過順エラー
グループ 1 で基準区間 PC1 と異なる区間があります:
  基準区間 PC1 の通過順: [1, 2, 3, 5, 10]

  【区間 PC2】
    通過順序が異なります:
      基準: [1, 2, 3, 5, 10]
      実際: [1, 2, 5, 3, 10]

確認してください。
```

#### 確認可否
**可（allow_confirmation=True）**

#### 実装関数
`check_section_passage_order(results, sections)`

---

## 4. ゼッケン通過順エラー

### エラータイプ
`zekken_order`

### 判定条件

#### 検出タイミング
Race読み込み時（validate_all関数）

#### 現在のエラー判定ロジック（詳細）

このエラーが「多すぎる」との指摘があるため、詳細に説明します。

##### 1. 前提条件の取得
```python
# グループごとに区間の正しい順序を取得（section設定ファイルから）
group_section_order = defaultdict(list)
for section in sections:
    group = section.group
    group_section_order[group].append(section.section)
```

##### 2. ゼッケンごとの通過区間を収集
```python
# ゼッケンごと、グループごとに通過した区間を記録
zekken_sections = defaultdict(lambda: defaultdict(list))
for result in results:
    if not result.status:  # ステータスがない場合のみ
        # この区間が属するグループを探す
        # 通過した区間をリストに追加
        zekken_sections[result.zekken][group].append(result.section)
```

##### 3. エラー判定の実行
```python
for zekken, group_passages in zekken_sections.items():
    for group, passed_sections in group_passages.items():
        expected_order = group_section_order[group]
        
        # ★重要: 通過区間が2つ未満の場合はスキップ
        if len(passed_sections) < 2:
            continue  # エラーとしない
        
        # 期待される順序を取得
        expected_passed = [s for s in expected_order if s in passed_sections]
        
        # ★エラー判定: 実際の通過順序と期待される順序が異なる場合
        if passed_sections != expected_passed:
            # エラーを記録
```

#### エラーが検出される具体的なケース

##### ケース1: 区間の逆転
```
期待される順序: PC1 → PC2 → PC3 → PC4
実際の通過順序: PC1 → PC2 → PC4 → PC3
→ PC3とPC4が逆転しているためエラー
```

##### ケース2: 区間のスキップ（歯抜け）
```
期待される順序: PC1 → PC2 → PC3 → PC4
実際の通過順序: PC1 → PC3 → PC4
→ PC2をスキップしているが、順序は保たれている
→ 期待される順序は [PC1, PC3, PC4] となる
→ 実際の順序と一致するため、エラーにならない

期待される順序: PC1 → PC2 → PC3 → PC4
実際の通過順序: PC1 → PC4 → PC3
→ PC2をスキップし、かつPC3とPC4が逆転
→ エラーになる
```

##### ケース3: 1つの区間のみ通過
```
期待される順序: PC1 → PC2 → PC3 → PC4
実際の通過順序: PC1
→ 通過区間が1つのみのため、順序の検証不可
→ エラーにならない（スキップされる）
```

#### エラーが多くなる理由

このロジックでは以下の場合にエラーが検出されます：

1. **すべてのゼッケンについて個別に判定**
   - 100台のゼッケンがあれば、最大100個のエラーが発生する可能性

2. **グループごとに判定**
   - 各ゼッケンが複数のグループを通過する場合、グループごとにエラーが発生

3. **厳格な順序チェック**
   - 期待される順序と実際の順序を完全一致で比較
   - 1つでも順序が異なればエラー

4. **スキップによるエラーは発生しない**
   - 区間をスキップしても、通過した区間の順序が正しければエラーにならない
   - ただし、スキップして逆転した場合はエラーになる

#### 詳細な問題箇所の特定

エラーメッセージには以下の詳細情報が含まれます：

##### 逆転の検出
```python
# 隣接する2つの区間の順序をチェック
for i in range(len(passed_sections) - 1):
    curr_section = passed_sections[i]
    next_section = passed_sections[i + 1]
    
    # 期待される順序でのインデックスを比較
    if curr_idx > next_idx:  # 逆転している
        reversals.append(f"{curr_section} → {next_section}")
```

##### 歯抜けの検出
```python
# 通過した区間の範囲内で、スキップされた区間を検出
first_expected_idx = 最初に通過した区間のインデックス
last_expected_idx = 最後に通過した区間のインデックス

# その範囲内で通過していない区間
for idx in range(first_expected_idx, last_expected_idx + 1):
    section = expected_order[idx]
    if section not in passed_set:
        missing_sections.append(section)  # 歯抜け
```

#### エラーメッセージ例

##### 基本的なエラー
```
⚠️ ゼッケン通過順エラー
ゼッケン 5 がグループ 1 で不正な順序で通過しています:

  期待される順序: PC1 → PC2 → PC3 → PC4
  実際の通過順序: PC1 → PC2 → PC4 → PC3

【問題箇所】
  逆転: PC4 → PC3

確認してください。
```

##### 歯抜けありのエラー
```
⚠️ ゼッケン通過順エラー
ゼッケン 10 がグループ 1 で不正な順序で通過しています:

  期待される順序: PC1 → PC3 → PC4
  実際の通過順序: PC1 → PC4 → PC3

【問題箇所】
  逆転: PC4 → PC3
  歯抜け（未通過）: PC2

確認してください。
```

#### 確認可否
**可（allow_confirmation=True）**

#### 実装関数
`check_zekken_passage_order(results, sections)`

---

## 5. ステータス不正エラー

### エラータイプ
`invalid_status`

### 判定条件

#### 検出タイミング
Race読み込み時（validate_all関数）

#### 検出ロジック
1. すべてのレース結果をループ処理
2. ステータスが`RIT`（リタイヤ）または`BLNK`（ブランク）の結果を検出
3. **以下のいずれかの条件を満たす場合にエラー**:
   - START時刻が存在する（result.start_time が存在し、値がある）
   - GOAL時刻が存在する（result.goal_time が存在し、値がある）

#### エラーメッセージ例
```
⚠️ ステータス不正エラー
区間 'PC2' でゼッケン 8 は RIT ステータスですが、
START時刻とGOAL時刻の両方が存在します。
確認してください。
```

#### 確認可否
**可（allow_confirmation=True）**

#### 実装関数
`check_invalid_status_with_time(results)`

---

## 6. 計測タイプ確認エラー

### エラータイプ
`measurement_type`

### 判定条件

#### 検出タイミング
Race読み込み時（validate_all関数）

#### 検出ロジック
1. レースフォルダ内のすべてのCSVファイルを読み込み
2. 各CSVファイルで列を探す:
   - `time`列を含む列名を検索
   - `type`列は`time`列の左側
   - `number`列は`time`列の右側
3. 各行をチェックして、**以下のすべての条件を満たす場合にエラー**:
   - `type`列の値が`T`（手動計測）
   - `number`列に値が入力されている（空でない、数値に変換可能）

#### エラーメッセージ例
```
⚠️ 計測タイプ確認
区間 'PC3' で手動計測（type=T）の時刻にゼッケン 15 が入力されています。
  時刻: 10:30:45
  ファイル: PC3GOAL.csv
確認してください。
```

#### 確認可否
**可（allow_confirmation=True）**

#### 実装関数
`check_measurement_type(race_folder)`

#### 補足
このエラーは警告的な性質があり、手動計測にゼッケンが入力されていることが本当に正しいかを確認するためのものです。

---

## 7. 計測データ不備エラー

### エラータイプ
`measurement_deficiency`

### 判定条件

#### 検出タイミング
**計算実行後**（validate_all関数にcalc_engineが渡された場合のみ）

#### 対象区間
- **PC競技**: チェック対象
- **CO競技**: チェック対象
- **PCG競技**: チェック対象外（スキップ）

#### 検出ロジック（PC競技）
1. 区間ごとに結果を集計
2. ステータスがある結果は除外
3. 各ゼッケンの`diff`（時刻のずれ）をチェック
4. **以下の条件を満たす場合にエラー**:
   ```
   abs(diff) >= 1.0 秒のゼッケン数 >= 総通過台数 / 2
   ```
   つまり、**半数以上が1秒以上ずれている場合**

#### 検出ロジック（CO競技）
1. 区間ごとに結果を集計
2. ステータスがある結果は除外
3. 各ゼッケンの`point`（得点）をチェック
4. **以下の条件を満たす場合にエラー**:
   ```
   point == 0 のゼッケン数 >= 総通過台数 / 2
   ```
   つまり、**半数以上が得点を取得できていない場合**

#### エラーメッセージ例（PC競技）
```
⚠️ 計測データ不備（PC競技）
区間 'PC2' で総通過台数 50台のうち、
30台（60.0%）が1秒以上ずれています。
計測データを確認してください。
```

#### エラーメッセージ例（CO競技）
```
⚠️ 計測データ不備（CO競技）
区間 'CO1' で総通過台数 50台のうち、
28台（56.0%）が得点を取得できていません。
計測データを確認してください。
```

#### 確認可否
**可（allow_confirmation=True）**

#### 実装関数
`check_measurement_deficiency(calc_engine, sections)`

#### 補足
このチェックは計算エンジンの結果（diff、point）が必要なため、計算実行後にのみ実行されます。

---

## 8. エラー確認可否について

### 確認不可能なエラー（重大エラー）

以下のエラーは`allow_confirmation=False`で、確認済みにすることができません：

1. **CSVファイル名重複**（csv_duplicate）
   - 理由: ファイル名の修正が必須
   - 対処: ファイル名を変更または削除

2. **ゼッケン重複**（zekken_duplicate）
   - 理由: CSVファイルの修正が必須
   - 対処: 重複行を削除または修正

### 確認可能なエラー

以下のエラーは`allow_confirmation=True`で、確認済みにすることができます：

1. **区間通過順**（section_order）
2. **ゼッケン通過順**（zekken_order）
3. **ステータス不正**（invalid_status）
4. **計測タイプ確認**（measurement_type）
5. **計測データ不備**（measurement_deficiency）

これらのエラーは、データが正常であることを確認した場合にのみ確認済みにしてください。

---

## 9. 同一エラー判定ロジック

エラーが再検出された際、以前の確認済みステータスを引き継ぐための判定基準：

### get_comparison_key() メソッド

各エラータイプに対して、一意のキーを生成します：

#### 1. CSVファイル名重複
```python
f"{error_type}:{section}"
```
- 例: `csv_duplicate:PC3GOAL`

#### 2. ゼッケン重複
```python
f"{error_type}:{section}:{zekken}"
```
- 例: `zekken_duplicate:PC1:5`

#### 3. 区間通過順
```python
f"{error_type}:{group}:{first_section}"
```
- 例: `section_order:1:PC1`

#### 4. ゼッケン通過順
```python
f"{error_type}:{zekken}:{group}"
```
- 例: `zekken_order:5:1`

#### 5. ステータス不正
```python
f"{error_type}:{section}:{zekken}:{status}"
```
- 例: `invalid_status:PC2:8:RIT`

#### 6. 計測タイプ確認
```python
f"{error_type}:{section}:{time}:{zekken}"
```
- 例: `measurement_type:PC3:10:30:45:15`

#### 7. 計測データ不備
```python
f"{error_type}:{section}"
```
- 例: `measurement_deficiency:PC2`

### 同一エラーの判定フロー

```python
# エラー検出時
new_error = ValidationError(...)
comparison_key = new_error.get_comparison_key()

# 以前に確認済みだったか確認
if comparison_key in confirmed_errors_map:
    new_error.confirmed = confirmed_errors_map[comparison_key]
```

この仕組みにより、データを修正して再読み込みしても、同じエラーの確認済みステータスが復元されます。

---

## 10. 全エラーの実行順序

### Race読み込み時
```
validate_all(race_folder, results, sections)
  ├─ 1. check_duplicate_filenames(race_folder)
  ├─ 2. check_duplicate_zekken_in_section(results)
  ├─ 3. check_section_passage_order(results, sections)
  ├─ 4. check_zekken_passage_order(results, sections)  ← エラーが多いのはここ
  ├─ 5. check_invalid_status_with_time(results)
  └─ 6. check_measurement_type(race_folder)
```

### 計算実行後
```
validate_all(race_folder, results, sections, calc_engine)
  ├─ 1～6. （上記と同じ）
  └─ 7. check_measurement_deficiency(calc_engine, sections)  ← 追加
```

---

## まとめ

### エラーの優先順位

1. **最優先（必ず修正）**:
   - CSVファイル名重複
   - ゼッケン重複

2. **高優先**:
   - ステータス不正

3. **中優先**:
   - 計測タイプ確認
   - 計測データ不備

4. **低優先（確認が必要）**:
   - 区間通過順
   - ゼッケン通過順

### ゼッケン通過順エラーが多い理由

現在の判定ロジックでは：
- すべてのゼッケンについて個別に判定
- グループごとに判定
- 2つ以上の区間を通過したゼッケンすべてが対象
- 期待される順序と実際の順序を厳格に比較

そのため、少しの順序の違いでも多数のエラーが検出されます。

### 対処方法

1. **重大エラーを最優先で修正**
   - CSVファイル名重複とゼッケン重複は必ず修正

2. **ゼッケン通過順エラーの確認**
   - エラー確認ウィンドウで個別に確認
   - データが正しい場合は「確認済み」にする
   - 確認済みにすると、未確認エラーのカウントに含まれない

3. **計算実行前の確認**
   - 未確認エラーが多数ある場合は警告が表示される
   - 重大エラーがある場合は必ず修正してから計算

---

## 参照

- 実装コード: `data_validator.py`
- ユーザーガイド: `ERROR_HANDLING_GUIDE.md`
- データ検証ガイド: `DATA_VALIDATION_GUIDE.md`
- 実装詳細: `ERROR_HANDLING_IMPLEMENTATION.md`
